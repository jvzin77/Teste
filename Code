import discord
from discord.ext import commands
from discord import app_commands
import re
import random
import asyncio
from datetime import datetime, timedelta, timezone
import os
import sys
import json


intents = discord.Intents.default()
intents.members = True  
intents.presences = True
intents.message_content = True  # Habilitando o acesso ao conte√∫do das mensagens

bot = commands.Bot(command_prefix="!", intents=intents)

# Vari√°vel global para indicar se o bot foi reiniciado pelo comando /reset
foi_reiniciado = False

@bot.event
async def on_ready():
    global foi_reiniciado
    print(f'Logado como {bot.user}')
    try:
        synced = await bot.tree.sync()
        print(f"Sincronizados {len(synced)} comando(s): {', '.join([cmd.name for cmd in synced])}")

        # Envia uma mensagem ao canal de status se o rein√≠cio foi solicitado pelo comando /reset
        if foi_reiniciado:
            canal_status = bot.get_channel(1305540878814810122)
            if canal_status is not None:
                await canal_status.send("Reinicia√ß√£o conclu√≠da com sucesso e bot pronto para uso!")
            # Reseta a vari√°vel para evitar mensagens extras no pr√≥ximo in√≠cio
            foi_reiniciado = False
    except Exception as e:
        print(f"Erro ao sincronizar comandos: {e}")

@bot.tree.command(name="userinfo", description="Mostra informa√ß√µes sobre um usu√°rio")
async def userinfo(interaction: discord.Interaction, user: discord.Member = None):
        if user is None:
            user = interaction.user

        embed = discord.Embed(title="Informa√ß√µes do Usu√°rio", color=discord.Color.blue())
        embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
        embed.add_field(name="Nome", value=user.name, inline=True)
        embed.add_field(name="Discriminador", value=user.discriminator, inline=True)
        embed.add_field(name="ID", value=user.id, inline=True)
        embed.add_field(name="Status", value=str(user.status).title(), inline=True)
        embed.add_field(name="Entrou no Servidor", value=user.joined_at.strftime("%d/%m/%Y %H:%M:%S"), inline=True)
        embed.add_field(name="Conta Criada", value=user.created_at.strftime("%d/%m/%Y %H:%M:%S"), inline=True)
        embed.add_field(name="Cargos", value=", ".join([role.mention for role in user.roles if role.name != "@everyone"]), inline=True)

        await interaction.response.send_message(embed=embed, ephemeral=False)

class AdicionarGrupo(app_commands.Group):
    def __init__(self):
        super().__init__(name="adicionar", description="Comandos para adicionar recursos")

    @app_commands.command(name="cargo", description="Adiciona um cargo ao usu√°rio")
    @app_commands.describe(user="O usu√°rio ao qual deseja adicionar o cargo", role="O cargo que deseja adicionar ao usu√°rio")
    async def cargo(self, interaction: discord.Interaction, user: discord.Member, role: discord.Role):
        # Verifica permiss√£o de administrador
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="Permiss√£o Insuficiente",
                description="**Apenas administradores podem usar este comando.**",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # Verifica se o usu√°rio j√° possui o cargo
        if role in user.roles:
            embed = discord.Embed(
                title="Erro",
                description=f"O usu√°rio {user.mention} j√° possui o cargo {role.mention}.",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        try:
            # Adiciona o cargo ao usu√°rio
            await user.add_roles(role)
            embed = discord.Embed(
                title="Sucesso",
                description=f"Cargo {role.mention} adicionado ao usu√°rio {user.mention} com sucesso!",
                color=discord.Color.green()
            )
            await interaction.response.send_message(embed=embed)

            # Aguarda antes de deletar a resposta original
            await asyncio.sleep(5)
            message = await interaction.original_response()
            await message.delete()
        except discord.Forbidden:
            embed = discord.Embed(
                title="Erro",
                description="Erro ao adicionar o cargo: **Permiss√µes insuficientes.**",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except discord.HTTPException as e:
            embed = discord.Embed(
                title="Erro",
                description=f"Erro ao adicionar o cargo: {str(e)}",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            embed = discord.Embed(
                title="Erro",
                description=f"Erro ao adicionar o cargo: {str(e)}",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)

# Adiciona o grupo de comandos ao bot
bot.tree.add_command(AdicionarGrupo())

@bot.tree.command(name="dado", description="Role um dado de 6 lados.")
async def dado(interaction: discord.Interaction):
    try:
        # Defere a resposta para permitir mais tempo
        await interaction.response.defer()

        # L√≥gica do comando
        resultado = random.randint(1, 6)
        embed = discord.Embed(
            title="Dado Jogado",
            description=f"O resultado foi: {resultado}",
            color=discord.Color.gold()
        )
        embed.set_footer(
            text=f"Jogado por: {interaction.user.display_name}",
            icon_url=interaction.user.avatar.url if interaction.user.avatar else interaction.user.default_avatar.url
        )
        # Envia a mensagem de resposta com o embed
        await interaction.followup.send(embed=embed)
    except Exception as e:
        # Envia uma mensagem de erro, caso ocorra um problema
        mensagem_erro = await interaction.followup.send(
            f"Erro ao jogar o dado: {str(e)}",
            ephemeral=True
        )
        # Aguarda 5 segundos antes de excluir a mensagem de erro
        await asyncio.sleep(5)
        await mensagem_erro.delete()

class RemoverGrupo(app_commands.Group):
    def __init__(self):
        super().__init__(name="remover", description="Comandos para remover recursos")

    @app_commands.command(name="cargo", description="Remove um cargo do usu√°rio")
    @app_commands.describe(user="O usu√°rio do qual deseja remover o cargo", role="O cargo que deseja remover do usu√°rio")
    async def cargo(self, interaction: discord.Interaction, user: discord.Member, role: discord.Role):
        # Verifica permiss√£o de administrador
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="Permiss√£o Insuficiente",
                description="**Apenas administradores podem usar este comando.**",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # Verifica se o usu√°rio possui o cargo
        if role not in user.roles:
            embed = discord.Embed(
                title="Erro",
                description=f"O usu√°rio {user.mention} n√£o possui o cargo {role.mention}.",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        try:
            # Remove o cargo do usu√°rio
            await user.remove_roles(role)
            embed = discord.Embed(
                title="Sucesso",
                description=f"Cargo {role.mention} removido do usu√°rio {user.mention} com sucesso!",
                color=discord.Color.green()
            )
            await interaction.response.send_message(embed=embed)

            # Aguarda antes de deletar a resposta original
            await asyncio.sleep(5)
            message = await interaction.original_response()
            await message.delete()
        except discord.Forbidden:
            embed = discord.Embed(
                title="Erro",
                description="Erro ao remover o cargo: **Permiss√µes insuficientes.**",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except discord.HTTPException as e:
            embed = discord.Embed(
                title="Erro",
                description=f"Erro ao remover o cargo: {str(e)}",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            embed = discord.Embed(
                title="Erro",
                description=f"Erro ao remover o cargo: {str(e)}",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)

# Adiciona o grupo de comandos ao bot
bot.tree.add_command(RemoverGrupo())

@bot.tree.command(name="avatar", description="Mostra o avatar do usu√°rio")
@discord.app_commands.describe(user="O usu√°rio do qual deseja mostrar o avatar")
async def avatar(interaction: discord.Interaction, user: discord.Member = None):
    try:
        if user is None:
            user = interaction.user

        embed = discord.Embed(title=f"Avatar de {user.display_name}", color=discord.Color.blue())

        # Verifica se o usu√°rio possui avatar antes de acessar a URL
        if user.avatar:
            embed.set_image(url=user.avatar.url)
        else:
            embed.description = "O usu√°rio n√£o possui um avatar."

        await interaction.response.send_message(embed=embed)
    except Exception as e:
        await interaction.response.send_message(f"Erro ao obter o avatar do usu√°rio: {str(e)}", ephemeral=True)

@bot.tree.command(name="serverinfo", description="Mostra informa√ß√µes sobre o servidor")
async def server_info(interaction: discord.Interaction):
    try:
        guild = interaction.guild
        embed = discord.Embed(title=f"Informa√ß√µes do Servidor: {guild.name}", color=discord.Color.blue())
        embed.add_field(name="ID do Servidor", value=guild.id, inline=True)
        embed.add_field(name="Dono do Servidor", value=guild.owner, inline=True)
        embed.add_field(name="N√∫mero de Membros", value=guild.member_count, inline=True)
        embed.add_field(name="Criado em", value=guild.created_at.strftime("%d/%m/%Y"), inline=True)
        await interaction.response.send_message(embed=embed)
    except Exception as e:
        error_embed = discord.Embed(title="Erro ao Obter Informa√ß√µes do Servidor", color=discord.Color.red())
        error_embed.add_field(name="Mensagem de Erro:", value="Falha ao obter informa√ß√µes do servidor. Tente novamente.")
        await interaction.response.send_message(embed=error_embed)

@server_info.error
async def server_info_error(ctx, error):
    if isinstance(error, commands.CommandError):
        error_embed = discord.Embed(title="Erro ao Executar o Comando", color=discord.Color.red())
        error_embed.add_field(name="Mensagem de Erro:", value="Verifique se o comando est√° correto e tente novamente.")
        await ctx.send(embed=error_embed)

@bot.tree.command(name="ban", description="Bane um usu√°rio")
@discord.app_commands.describe(user="O usu√°rio que deseja banir")
@discord.app_commands.describe(reason="O motivo do banimento (opcional)")
async def ban(interaction: discord.Interaction, user: discord.Member, *, reason: str = "Nenhum motivo fornecido"):
    try:
        if not interaction.user.guild_permissions.ban_members:
            embed = discord.Embed(title="Permiss√£o Negada", description="Voc√™ n√£o tem permiss√£o para usar este comando.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        if user == interaction.user:
            embed = discord.Embed(title="A√ß√£o Inv√°lida", description="Voc√™ n√£o pode se banir.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        embed = discord.Embed(title="Usu√°rio Banido", description=f"{user.mention} foi banido.", color=discord.Color.red())
        embed.add_field(name="Usu√°rio", value=user.mention, inline=True)
        embed.add_field(name="Banido por", value=interaction.user.mention, inline=True)
        embed.add_field(name="Motivo", value=reason, inline=False)
        embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
        embed.set_footer(text=f"ID do usu√°rio: {user.id}")

        await interaction.guild.ban(user, reason=reason)
        await interaction.response.send_message(embed=embed)
        await asyncio.sleep(5)
        message = await interaction.original_response()
        await message.delete()

    except discord.Forbidden:
        embed = discord.Embed(title="Erro", description="Permiss√µes insuficientes para banir o usu√°rio.", color=discord.Color.red())
        await interaction.response.send_message(embed=embed, ephemeral=True)
    except discord.HTTPException as e:
        embed = discord.Embed(title="Erro", description=f"Erro ao banir o usu√°rio: {str(e)}", color=discord.Color.red())
        await interaction.response.send_message(embed=embed, ephemeral=True)
    except Exception as e:
        embed = discord.Embed(title="Erro", description=f"Erro ao banir o usu√°rio: {str(e)}", color=discord.Color.red())
        await interaction.response.send_message(embed=embed, ephemeral=True)

@bot.tree.command(name="unban", description="Desbane um usu√°rio por ID")
@discord.app_commands.describe(id="O ID do usu√°rio que deseja desbanir")
@discord.app_commands.describe(reason="O motivo do desbanimento (opcional)")
async def unban(interaction: discord.Interaction, id: str, *, reason: str = "Nenhum motivo fornecido"):
    try:
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(title="Permiss√£o Negada", description="Voc√™ n√£o tem permiss√£o para usar este comando.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        try:
            user_id = int(id)
        except ValueError:
            embed = discord.Embed(title="ID Inv√°lido", description="O ID fornecido n√£o √© v√°lido.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        user = await bot.fetch_user(user_id)
        await interaction.guild.unban(user, reason=reason)

        embed = discord.Embed(title="Usu√°rio Desbanido", description=f"{user.mention} foi desbanido.", color=discord.Color.green())
        embed.add_field(name="Usu√°rio", value=user.mention, inline=True)
        embed.add_field(name="Desbanido por", value=interaction.user.mention, inline=True)
        embed.add_field(name="Motivo", value=reason, inline=False)
        embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
        embed.set_footer(text=f"ID do usu√°rio: {user.id}")

        await interaction.response.send_message(embed=embed)
    except discord.Forbidden:
        embed = discord.Embed(title="Erro", description="Permiss√µes insuficientes para desbanir o usu√°rio.", color=discord.Color.red())
        await interaction.response.send_message(embed=embed, ephemeral=True)
    except discord.HTTPException as e:
        embed = discord.Embed(title="Erro", description=f"Erro ao desbanir o usu√°rio: {str(e)}", color=discord.Color.red())
        await interaction.response.send_message(embed=embed, ephemeral=True)
    except Exception as e:
        embed = discord.Embed(title="Erro", description=f"Erro ao desbanir o usu√°rio: {str(e)}", color=discord.Color.red())
        await interaction.response.send_message(embed=embed, ephemeral=True)

@bot.tree.command(name="clear", description="Limpa mensagens no canal")
@discord.app_commands.describe(quantidade="O n√∫mero de mensagens que deseja apagar")
async def clear(interaction: discord.Interaction, quantidade: int):
    if not interaction.user.guild_permissions.manage_messages:
        await interaction.response.send_message("Voc√™ n√£o tem permiss√£o para usar este comando. Apenas membros com permiss√£o de gerenciar mensagens podem usar.", ephemeral=True)
        return

    if quantidade < 1 or quantidade > 1000:
        await interaction.response.send_message("Voc√™ deve especificar uma quantidade entre 1 e 1000.", ephemeral=True)
        return

    await interaction.response.send_message("‚åõ Processando...", ephemeral=True)  # Envia uma mensagem r√°pida de feedback

    try:
        deleted = await interaction.channel.purge(limit=quantidade)
        success_message = f"üéâ | O chat teve {len(deleted)} mensagens apagadas com sucesso! Por {interaction.user.mention}"
        await interaction.followup.send(success_message)  # Envia a mensagem de sucesso no canal
    except discord.Forbidden:
        await interaction.followup.send("Erro ao apagar mensagens: Permiss√µes insuficientes.", ephemeral=True)
    except discord.HTTPException as e:
        await interaction.followup.send(f"Erro ao apagar mensagens: {str(e)}", ephemeral=True)
    except Exception as e:
        await interaction.followup.send(f"Erro ao apagar mensagens: {str(e)}", ephemeral=True)

@bot.tree.command(name="kick", description="Expulsa um usu√°rio do servidor")
@discord.app_commands.describe(user="O usu√°rio que deseja expulsar", reason="O motivo da expuls√£o (opcional)")
async def kick(interaction: discord.Interaction, user: discord.Member, *, reason: str = "Nenhum motivo fornecido"):
    try:
        if not interaction.user.guild_permissions.kick_members:
            embed = discord.Embed(title="Permiss√£o Negada", description="Voc√™ n√£o tem permiss√£o para usar este comando.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        if user == interaction.user:
            embed = discord.Embed(title="A√ß√£o Inv√°lida", description="Voc√™ n√£o pode se expulsar.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        embed = discord.Embed(title="Usu√°rio Expulso", description=f"{user.mention} foi expulso.", color=discord.Color.red())
        embed.add_field(name="Usu√°rio", value=user.mention, inline=True)
        embed.add_field(name="Expulso por", value=interaction.user.mention, inline=True)
        embed.add_field(name="Motivo", value=reason, inline=False)
        embed.set_thumbnail(url=user.avatar.url if user.avatar else user.default_avatar.url)
        embed.set_footer(text=f"ID do usu√°rio: {user.id}")

        await interaction.guild.kick(user, reason=reason)
        await interaction.response.send_message(embed=embed)
        await asyncio.sleep(5)
        message = await interaction.original_response()
        await message.delete()

    except discord.Forbidden:
        embed = discord.Embed(title="Erro", description="Permiss√µes insuficientes para expulsar o usu√°rio.", color=discord.Color.red())
        await interaction.response.send_message(embed=embed, ephemeral=True)
    except discord.HTTPException as e:
        embed = discord.Embed(title="Erro", description=f"Erro ao expulsar o usu√°rio: {str(e)}", color=discord.Color.red())
        await interaction.response.send_message(embed=embed, ephemeral=True)
    except Exception as e:
        embed = discord.Embed(title="Erro", description=f"Erro ao expulsar o usu√°rio: {str(e)}", color=discord.Color.red())
        await interaction.response.send_message(embed=embed, ephemeral=True)

# IDs dos cargos de advert√™ncia
ADV_ROLES = {
    "ADV1": 1248328164892086385,
    "ADV2": 1250972755764183091,
    "ADV3": 1250972827046383626,
}

class Advertencia(app_commands.Group):
    def __init__(self):
        super().__init__(name="advertencia", description="Comandos para aplicar e remover advert√™ncias")

    @app_commands.command(name="add", description="Adiciona uma advert√™ncia ao usu√°rio")
    @app_commands.describe(user="Selecione o usu√°rio a ser advertido", role="Cargo de advert√™ncia (opcional)", reason="Motivo da advert√™ncia (opcional)")
    @app_commands.choices(
        role=[
            app_commands.Choice(name="Advert√™ncia 1", value="ADV1"),
            app_commands.Choice(name="Advert√™ncia 2", value="ADV2"),
            app_commands.Choice(name="Advert√™ncia 3", value="ADV3"),
        ]
    )
    async def add(self, interaction: discord.Interaction, user: discord.Member, role: str = None, reason: str = "Nenhuma raz√£o especificada"):
        # Verifica se o usu√°rio tem permiss√£o para adicionar o cargo
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="Permiss√£o Insuficiente",
                description="**Apenas administradores podem usar este comando.**",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # Se n√£o for especificado nenhum cargo, envia uma mensagem informando e sai
        if role is None:
            embed = discord.Embed(
                title="Cargo n√£o especificado",
                description="Voc√™ deve selecionar um cargo de advert√™ncia para aplicar.",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # Obt√©m o cargo de advert√™ncia
        role_id = ADV_ROLES.get(role)
        if role_id is None:
            await interaction.response.send_message("Cargo de advert√™ncia n√£o encontrado.", ephemeral=True)
            return

        role = interaction.guild.get_role(role_id)

        # Verifica se o usu√°rio j√° possui o cargo de advert√™ncia
        if role in user.roles:
            embed = discord.Embed(
                title="Advert√™ncia J√° Aplicada",
                description=f"O usu√°rio {user.mention} j√° possui o cargo de {role.mention}.",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # Adiciona o cargo de advert√™ncia ao usu√°rio
        try:
            await user.add_roles(role)
            embed = discord.Embed(
                title="Advert√™ncia Aplicada",
                description=f"O cargo de **{role.mention}** foi adicionado ao usu√°rio {user.mention}.\n**Motivo:** {reason}",
                color=discord.Color.green()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except discord.Forbidden:
            await interaction.response.send_message("Erro ao adicionar o cargo: Permiss√µes insuficientes.", ephemeral=True)
        except discord.HTTPException as e:
            await interaction.response.send_message(f"Erro ao adicionar o cargo: {str(e)}", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"Erro inesperado: {str(e)}", ephemeral=True)

    @app_commands.command(name="remove", description="Remove uma advert√™ncia do usu√°rio")
    @app_commands.describe(user="Selecione o usu√°rio a ter a advert√™ncia removida", role="Cargo de advert√™ncia (opcional)")
    @app_commands.choices(
        role=[
            app_commands.Choice(name="Advert√™ncia 1", value="ADV1"),
            app_commands.Choice(name="Advert√™ncia 2", value="ADV2"),
            app_commands.Choice(name="Advert√™ncia 3", value="ADV3"),
        ]
    )
    async def remove(self, interaction: discord.Interaction, user: discord.Member, role: str = None):
        # Verifica se o usu√°rio tem permiss√£o para remover o cargo
        if not interaction.user.guild_permissions.administrator:
            embed = discord.Embed(
                title="Permiss√£o Insuficiente",
                description="**Apenas administradores podem usar este comando.**",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # Se n√£o for especificado nenhum cargo, envia uma mensagem informando e sai
        if role is None:
            embed = discord.Embed(
                title="Cargo n√£o especificado",
                description="Voc√™ deve selecionar um cargo de advert√™ncia para remover.",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # Obt√©m o cargo de advert√™ncia
        role_id = ADV_ROLES.get(role)
        if role_id is None:
            await interaction.response.send_message("Cargo de advert√™ncia n√£o encontrado.", ephemeral=True)
            return

        role = interaction.guild.get_role(role_id)

        # Verifica se o usu√°rio n√£o possui o cargo de advert√™ncia
        if role not in user.roles:
            embed = discord.Embed(
                title="Nenhuma Advert√™ncia Encontrada",
                description=f"O usu√°rio {user.mention} n√£o possui o cargo de {role.mention}.",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # Remove o cargo de advert√™ncia do usu√°rio
        try:
            await user.remove_roles(role)
            embed = discord.Embed(
                title="Advert√™ncia Removida",
                description=f"O cargo de **{role.mention}** foi removido do usu√°rio {user.mention}.",
                color=discord.Color.green()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except discord.Forbidden:
            await interaction.response.send_message("Erro ao remover o cargo: Permiss√µes insuficientes.", ephemeral=True)
        except discord.HTTPException as e:
            await interaction.response.send_message(f"Erro ao remover o cargo: {str(e)}", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"Erro inesperado: {str(e)}", ephemeral=True)

# Adiciona o grupo de comandos ao bot
bot.tree.add_command(Advertencia())

@bot.tree.command(name="roleinfo", description="Mostra informa√ß√µes sobre um cargo espec√≠fico.")
@discord.app_commands.describe(role="O cargo sobre o qual deseja obter informa√ß√µes")
async def role_info(interaction: discord.Interaction, role: discord.Role):
    identic_emoji = "<:Identic:1251726244500738099>"
    config_emoji = "<:Config:1251726327707602996>"
    calen_emoji = "<:Calen:1251726417016655974>"
    brush_emoji = "üñåÔ∏è"
    okv_emoji = "<:CheckV:1251726045657436242>"
    nox_emoji = "<:NoX:1251726507433529445>"

    mentionable = role.mentionable
    hoist = role.hoist
    managed = role.managed

    # Define a cor da embed para branca usando o c√≥digo hexadecimal
    embed = discord.Embed(color=0xFFFFFF)

    properties = [
        (mentionable, "Mencion√°vel"),
        (hoist, "Mostrado Separadamente"),
        (managed, "Integra√ß√£o")
    ]

    properties_str = ""
    for prop_value, prop_name in properties:
        emoji = okv_emoji if prop_value else nox_emoji
        properties_str += f"{emoji} {prop_name}\n"

    # Adiciona o nome do cargo na embed sem t√≠tulo
    embed.description = role.name

    # Identidade
    embed.add_field(name=f"{identic_emoji} Identidade", value=f"{role.id}", inline=False)

    # Propriedades
    embed.add_field(name=f"{config_emoji} Propriedades", value=properties_str, inline=False)

    # Tempo de Cargo Criado
    created_at_timestamp = role.created_at.timestamp()
    embed.add_field(name=f"{calen_emoji} Cargo Criado", value=f"<t:{int(created_at_timestamp)}:F>", inline=False)

    # C√≥digo da Cor
    color_code = str(role.color)
    embed.add_field(name=f"{brush_emoji} C√≥digo da Cor", value=color_code, inline=False)

    # Permiss√µes
    permission_names = {
        "create_instant_invite": "Criar Convite Instant√¢neo",
        "add_reactions": "Adicionar Rea√ß√µes",
        "stream": "Transmitir",
        "read_messages": "Ler Mensagens",
        "send_messages": "Enviar Mensagens",
        "embed_links": "Inserir Links",
        "attach_files": "Anexar Arquivos",
        "read_message_history": "Ler Hist√≥rico de Mensagens",
        "mention_everyone": "Mencionar Todos",
        "use_external_emojis": "Emojis Externos",
        "connect": "Conectar",
        "speak": "Falar",
        "use_voice_activation": "Usar Ativa√ß√£o por Voz",
        "change_nickname": "Mudar Apelido",
        "use_application_commands": "Usar Comandos de Aplicativo",
        "request_to_speak": "Solicitar para Falar",
        "create_public_threads": "Criar T√≥picos P√∫blicos",
        "create_private_threads": "Criar T√≥picos Privados",
        "use_external_stickers": "Adesivos Externos",
        "send_messages_in_threads": "Enviar Mensagens em T√≥picos",
        "use_embedded_activities": "Usar Atividades Incorporadas",
        "use_soundboard": "Usar Mesa de Som",
        "create_expressions": "Criar Express√µes",
        "use_external_sounds": "Usar Sons Externos",
        "send_voice_messages": "Enviar Mensagens de Voz"
    }

    permissions = []
    for perm, value in role.permissions:
        if value:
            permissions.append(permission_names.get(perm, perm.replace("_", " ").capitalize()))

    permissions_str = "\n".join([f"``{perm}``" for perm in permissions])
    embed.add_field(name="Permiss√µes", value=permissions_str, inline=False)

    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="ping", description="Mostra a lat√™ncia atual do bot.")
async def ping(interaction: discord.Interaction):
    # Obtendo a lat√™ncia em milissegundos
    latency = bot.latency * 1000  # em milissegundos

    # Criando o Embed
    embed = discord.Embed(
        title="Pong!",
        description=f"**Lat√™ncia do bot:** {latency:.2f}ms",
        color=discord.Color.green()
    )

    embed.set_footer(text="Comando de ping executado com sucesso!")

    # Enviando a resposta no formato de embed
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="reset", description="Reinicia o bot.")
async def reset(interaction: discord.Interaction):
    global foi_reiniciado
    if interaction.user.id != 643956388845846538:
        await interaction.response.send_message("Voc√™ n√£o tem permiss√£o para reiniciar o bot.", ephemeral=True)
        return

    # Define a vari√°vel para indicar que o reset foi solicitado via comando
    foi_reiniciado = True
    await interaction.response.send_message("Reiniciando o bot...", ephemeral=True)

    # Envia mensagem ao canal de status que o bot est√° reiniciando
    canal_status = bot.get_channel(1305540878814810122)  # ID do canal de status
    if canal_status:
        await canal_status.send("Bot est√° reiniciando...")

    print("Comando /reset acionado. Reiniciando o bot...")  # Log para o console

    # Tenta reiniciar o bot
    try:
        os.execv(sys.executable, ['python'] + sys.argv)
    except Exception as e:
        await interaction.followup.send(f"Erro ao reiniciar o bot: {str(e)}", ephemeral=True)
        print(f"Erro ao reiniciar: {e}")  # Log de erro no console

@bot.event
async def on_ready():
    global foi_reiniciado
    try:
        # Envia mensagem ao canal de status indicando que o bot foi iniciado
        canal_status = bot.get_channel(1305540878814810122)  # ID do canal de status
        if canal_status:
            if foi_reiniciado:
                await canal_status.send("Bot reiniciado com sucesso e pronto para uso!")
                await canal_status.send("A reinicializa√ß√£o foi conclu√≠da.")  # Mensagem confirmando que a reinicializa√ß√£o foi conclu√≠da.
                foi_reiniciado = False  # Reseta a vari√°vel ap√≥s enviar a mensagem de rein√≠cio conclu√≠do
            else:
                await canal_status.send("Bot iniciado com sucesso!")

        # Log para o console (opcional)
        print(f'Logado como {bot.user}')
        synced = await bot.tree.sync()
        print(f"Comando(s) sincronizado(s): {', '.join([cmd.name for cmd in synced])}")

    except Exception as e:
        print(f"Erro ao sincronizar comandos: {e}")
